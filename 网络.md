## TCP/IP协议
### 物理层
有物理地址，用交换机处理
### 网络层
使用IP（IPV4）协议
#### IP地址
总共32位，通过十进制看的话分为4个数字，每个占8位
分为两层，分别用网络层+主机号
网络号通过子网掩码确定
![enter description here](./images/1714448328494.png)
#### IP地址分类
![enter description here](./images/1714448368643.png)
### TCP协议
面向连接、可靠的、字节流
四元组确定连接
![enter description here](./images/1714449587493.png)
#### 协议头
![enter description here](./images/1714448443887.png)
ACK（1）：确认应答字段有效
SYN（1）：序列号有效
RST（1）：TCP连接出现异常，强制断开
FIN（1）：表示今后不需要发送数据，希望连接断开
#### 三次握手
![enter description here](./images/1714449632566.png)
#### 为什么需要三次连接？
1. 确定双方序列号（初始化双方版本号）
2. 防止历史连接带来的干扰（两次连接无法确定对方是否收到，连接就建立了），造成资源浪费
#### 第一次握手丢失
客户端会超时重传，有次数（默认五次）
等待时间分别为1秒、2秒、4秒、......
![enter description here](./images/1714450561925.png)
#### 第二次握手丢失
客户端会触发第一次握手丢失
服务端进行重传，次数（默认5次）
![enter description here](./images/1714450593605.png)
#### 第三次握手丢失
服务端会进行第二次握手丢失
第三次握手是客户端发送的ACK报文
因为ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文（二次握手重传）
![enter description here](./images/1714450759492.png)
#### 什么是 SYN 攻击？如何避免 SYN 攻击？
TCP连接有两个队列
1. 半连接队列：连接未建立
2. 全连接队列：已经建立的连接
![enter description here](./images/1714450940458.png)
SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。
#### 解决方案
1. 扩大网卡数据包缓存池
2. 增大半连接队列
3. 开启net.ipv4.tcp_syncookies：开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接（问题很大）
4. 缩小第一、二次握手重传次数

### 四次挥手
![enter description here](./images/1714451125448.png)
#### 为什么需要四次挥手
关闭连接时仅仅是客户端不需要发送数据，客户端还能接受数据
服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接
#### 挥手丢失
挥手丢失跟握手丢失相似，默认次数为3次，3次后强制断开连接
 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接
#### 为什么需要TIME_WAIT
1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收(消费还在传输中的数据包)
2. 保证「被动关闭连接」的一方，能被正确的关闭（挥手ACK报文重传）
### 重传机制
### 超时重传
RTT：数据发送时刻到接收到确认的时刻的差值
RTO：超时重传时间，RTO时间由系统计算
![enter description here](./images/1714452336925.png)
### 快速重传
![enter description here](./images/1714452597398.png)
连续三次收到同个ACK（2），知道seq2没收到
问题：重传的时候，是重传一个，还是重传所有的问题
SACK 方法：在TCP头部加一个SACK字段，恢复收到的时哪个报文，避免重复发送
## 滑动窗口
窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除

这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

所以，通常窗口的大小是由接收方的窗口大小来决定的。

### 慢重启
![enter description here](./images/1714468243454.png)
成二次方增加
当大于等于慢启动门限（ssthresh）使用拥塞避免算法
### 拥塞避免算法
![enter description here](./images/1714468499669.png)
### 拥塞发生
#### 超时重传
ssthresh 设为 cwnd/2，
cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1，linux是10）
#### 快速重传
cwnd = cwnd/2 ，也就是设置为原来的一半;
ssthresh = cwnd
进入快速恢复
#### 快速恢复
1. 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
2. 重传丢失的数据包；
3. 如果再收到重复的 ACK，那么 cwnd 增加 1；
4. 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
![enter description here](./images/1714469184651.png)
为什么有第四步：
在快速恢复的过程中，首先 ssthresh = cwnd/2，然后 cwnd = ssthresh + 3，表示网络可能出现了阻塞，所以需要减小 cwnd 以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的数据包；
随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。这个过程的目的是尽快将丢失的数据包发给目标。
如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束

## HTTP
超文本传协议
### 状态码
![enter description here](./images/1714470316975.png)
### 常见字段
Host 字段：客户端发送请求时，用来指定服务器的域名
Content-Length 字段：服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度
Connection 字段：字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用
Content-Type：字段用于服务器回应时，告诉客户端，本次数据是什么格式